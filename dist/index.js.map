{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["'use strict';\r\nimport 'reflect-metadata';\r\nimport each from 'async/each';\r\nlet validatejs = require('validate.js');\r\n\r\n\r\nexport class TestClass {\r\n\r\n  constructor(name: string) {\r\n    this.testString = name;\r\n  }\r\n\r\n  @MinLen(2)\r\n  @MaxLen(10)\r\n  testString: string;\r\n}\r\n\r\nexport interface ValidatorError {\r\n  /**\r\n   * Name of the target class that was validated.\r\n   */\r\n  target: string;\r\n  /**\r\n   * Target's property on which validation is applied.\r\n   */\r\n  property: string;\r\n  /**\r\n   * Error's type.\r\n   */\r\n  type: string;\r\n  /**\r\n   * Error's message.\r\n   */\r\n  message: string;\r\n  /**\r\n   * Value of that target's property, that didn't pass a validation.\r\n   */\r\n  value: any;\r\n}\r\n\r\n/**\r\n * Options used to pass to validation decorators.\r\n */\r\nexport interface ValidatorOptions {\r\n  /**\r\n   * Specifies if validated value is an array and each of its item must be validated.\r\n   */\r\n  each?: boolean;\r\n  /**\r\n   * Error message used to be used on validation fail.\r\n   * You can use '$value' to use value that was failed by validation.\r\n   * You can use '$constraint1' and '$constraint2' keys in the message string,\r\n   * and they will be replaced with constraint values if they exist.\r\n   * Message can be either string, either a function that returns a string.\r\n   * Second option allows to use values and custom messages depend of them.\r\n   */\r\n  message?: string | ((value?: any, constraint1?: any, constraint2?: any) => string);\r\n  /**\r\n   * Validation groups used for this validation.\r\n   */\r\n  groups?: string[];\r\n  /**\r\n   * Indicates if validation must be performed always, no matter of validation groups used.\r\n   */\r\n  always?: boolean;\r\n}\r\n\r\nexport class Validator {\r\n\r\n  async getCustMetadata(target: Object, callback, validatorOptions?: ValidatorOptions) {\r\n\r\n  }\r\n\r\n  validate(target: Object, validatorOptions?: ValidatorOptions) {\r\n    for (let propertyName in target) {\r\n      if (!target.hasOwnProperty(propertyName)) {\r\n        continue;\r\n      }\r\n      let keys = Reflect.getMetadataKeys(target, propertyName);\r\n      let validators = Reflect.getMetadata('tsvalidate:validators', target, propertyName);\r\n      let types = Reflect.getMetadata('design:type', target, propertyName);\r\n      // console.log(validators + '\\n' + types);\r\n      //\r\n\r\n      // for (let validator in validators) {\r\n      //   switch(validator.type) {\r\n      //       case \"MaxLen\":\r\n      //         if (target[propertyName] > )\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nexport function MaxLen(value, validatorOptions?: ValidatorOptions) {\r\n  return function(target: Object, propertyName: string) {\r\n    let validators = Reflect.getMetadata('tsvalidate:validators', target, propertyName);\r\n    if (!validators) {\r\n      validators = [];\r\n    }\r\n    validators.push({ type: 'MaxLen', value: value, validatorOptions });\r\n    Reflect.defineMetadata('tsvalidate:validators', validators, target, propertyName);\r\n  };\r\n}\r\n\r\nexport function MinLen(value, validatorOptions?: ValidatorOptions) {\r\n  return function(target: Object, propertyName: string) {\r\n    let validators = Reflect.getMetadata('tsvalidate:validators', target, propertyName);\r\n    if (!validators) {\r\n      validators = [];\r\n    }\r\n    validators.push({ type: 'MinLen', value: value, validatorOptions });\r\n    Reflect.defineMetadata('tsvalidate:validators', validators, target, propertyName);\r\n  };\r\n}\r\n\r\nexport function Contains(value, validatorOptions?: ValidatorOptions) {\r\n  return function(target: Object, propertyName: string) {\r\n    let validators = Reflect.getMetadata('tsvalidate:validators', target, propertyName);\r\n    if (!validators) {\r\n      validators = [];\r\n    }\r\n    validators.push({ type: 'Contains', value: value, validatorOptions });\r\n    Reflect.defineMetadata('tsvalidate:validators', validators, target, propertyName);\r\n  };\r\n}\r\n\r\nexport function IsEmpty(value, validatorOptions?: ValidatorOptions) {\r\n  return function(target: Object, propertyName: string) {\r\n    let validators = Reflect.getMetadata('tsvalidate:validators', target, propertyName);\r\n    if (!validators) {\r\n      validators = [];\r\n    }\r\n    validators.push({ type: 'IsEmpty', value: value, validatorOptions });\r\n    Reflect.defineMetadata('tsvalidate:validators', validators, target, propertyName);\r\n  };\r\n}\r\n\r\nexport function IsNotEmpty(value, validatorOptions?: ValidatorOptions) {\r\n  return function(target: Object, propertyName: string) {\r\n    let validators = Reflect.getMetadata('tsvalidate:validators', target, propertyName);\r\n    if (!validators) {\r\n      validators = [];\r\n    }\r\n    validators.push({ type: 'IsNotEmpty', value: value, validatorOptions });\r\n    Reflect.defineMetadata('tsvalidate:validators', validators, target, propertyName);\r\n  };\r\n}\r\n"],"sourceRoot":"/source/"}